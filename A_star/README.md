# A*算法
## f(n)=g(n)+h(n)

+ __f(n)__ 是节点n的总代价。
+ __g(n)__ 是节点n距离起点的代价。
+ __h(n)__ 是节点n距离终点的预计代价(启发函数)

+ open_set 表示待遍历的节点
+ close_set 表示遍历过的节点
## 启发函数
1. 在极端情况下，当启发函数h(n)始终为0，则将由g(n)决定节点的优先级，此时算法就退化成了Dijkstra算法。
2. 如果h(n)始终小于等于节点n到终点的代价，则A*算法保证一定能够找到最短路径。但是当h(n)的值越小，算法将遍历越多的节点，也就导致算法越慢。
3. 如果h(n)完全等于节点n到终点的代价，则A*算法将找到最佳路径，并且速度很快。可惜的是，并非所有场景下都能做到这一点。因为在没有达到终点之前，我们很难确切算出距离终点还有多远。
4. 如果h(n)的值比节点n到终点的代价要大，则A*算法不能保证找到最短路径，不过此时会很快。
5. 在另外一个极端情况下，如果h(n)相较于g(n)大很多，则此时只有h(n)产生效果，这也就变成了最佳优先搜索。
## 关于几种距离：
+ __曼哈顿距离__(Manhattan distance)  
四个方向的运动  $$distance=(dis_x+dis_y)*D$$
+ __对角距离__  
八个方向的运动  
$$distance=(dis_x+dis_y)*D+(\sqrt{2}D-2*D)*min(dis_x,dis_y)$$
+ __欧几里得距离__  
任意方向的运动  
$$distance=\sqrt{(dis_x)^2+(dis_y)^2}$$
## 伪代码
~~~
初始化open_set、close_set；
将起点加入open_set中，并设置cost=0
while True:
    if open_set为空:
        出现闭合空间，不存在路径，算法结束。
    从open_set中选取cost最小的节点n。
    if 节点n为终点：
        从终点开始逐步追踪parent节点，一直达到起点；
        返回找到的结果路径，算法结束；
    if 节点n不是终点：
        将节点n从open_set中删除，并加入close_set中；
        遍历节点n所有的邻近节点m：
            if 邻近节点m在close_set中：
                跳过，选取下一个邻近节点
            if 邻近节点m也不在open_set中:
                设置节点m的parent为节点n
                计算节点m的cost
                将节点m加入open_set中
~~~